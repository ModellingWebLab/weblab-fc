# cython: profile=True
#
#
# Web Lab model hodgkin_huxley_squid_axon_model_1952_modified
#
# Generated by fc 0.0.1 on 2020-01-28 00:42:31
#
#
#
cimport fc.sundials.sundials as Sundials
cimport libc.math as math
cimport numpy as np

import numpy as np
import os
import shutil
import sys

import fc.language.values as V
from fc.environment import ModelWrapperEnvironment
from fc.error_handling import ProtocolError
from fc.sundials.solver cimport CvodeSolver


cdef int _evaluate_rhs(Sundials.realtype var_time,
                       Sundials.N_Vector y,
                       Sundials.N_Vector ydot,
                       void* user_data):
    """
    Cython wrapper around a model RHS that uses numpy, for calling by CVODE.

    See :meth:`fc.sundials.solver._evaluate_rhs()`.
    """
    # We passed the Python model object in as CVODE user data; get it back as an object
    model = <object>user_data
    cdef np.ndarray[Sundials.realtype, ndim=1] parameters = <np.ndarray>model.parameters

    # Unpack state variables
    cdef double var_V = (<Sundials.N_VectorContent_Serial>y.content).data[0]
    cdef double var_m = (<Sundials.N_VectorContent_Serial>y.content).data[1]
    cdef double var_h = (<Sundials.N_VectorContent_Serial>y.content).data[2]
    cdef double var_n = (<Sundials.N_VectorContent_Serial>y.content).data[3]

    # Mathematics
    cdef double var_g_L = 0.3
    cdef double var_Cm = 1.0
    cdef double var_E_R = -75.0
    cdef double var_E_L = 10.613 + var_E_R
    cdef double var_i_L = (-var_E_L + var_V) * var_g_L
    cdef double var_stim_amplitude = -20.0
    cdef double var_stim_duration = 0.5
    cdef double var_stim_end = 10000.0
    cdef double var_stim_period = 1000.0
    cdef double var_stim_start = 10.0
    cdef double var_i_Stim = ((var_stim_amplitude) if (var_time >= var_stim_start and var_time <= var_stim_end and var_stim_duration >= -var_stim_start - var_stim_period * math.floor((-var_stim_start + var_time) / var_stim_period) + var_time) else (0.0))
    cdef double var_E_K = -12.0 + var_E_R
    cdef double var_g_K = parameters[1]
    cdef double var_alpha_n = -0.01 * (65.0 + var_V) / (-1.0 + math.exp(-6.5 - 0.1 * var_V))
    cdef double var_beta_n = 0.125 * math.exp(0.9375 + 0.0125 * var_V)
    cdef double d_dt_n = (1.0 - var_n) * var_alpha_n - var_beta_n * var_n
    cdef double var_i_K = var_n**4.0 * (-var_E_K + var_V) * var_g_K
    cdef double var_E_Na = 115.0 + var_E_R
    cdef double var_g_Na = parameters[0]
    cdef double var_alpha_h = 0.07 * math.exp(-3.75 - 0.05 * var_V)
    cdef double var_beta_h = 1.0 / (1.0 + math.exp(-4.5 - 0.1 * var_V))
    cdef double d_dt_h = (1.0 - var_h) * var_alpha_h - var_beta_h * var_h
    cdef double var_alpha_m = -0.1 * (50.0 + var_V) / (-1.0 + math.exp(-5.0 - 0.1 * var_V))
    cdef double var_beta_m = 4.0 * math.exp(-4.166666666666667 - 0.05555555555555555 * var_V)
    cdef double d_dt_m = (1.0 - var_m) * var_alpha_m - var_beta_m * var_m
    cdef double var_i_Na = var_m**3.0 * (-var_E_Na + var_V) * var_g_Na * var_h
    cdef double d_dt_V = (-var_i_L - var_i_Stim - var_i_K - var_i_Na) / var_Cm

    # Pack state variable derivatives
    (<Sundials.N_VectorContent_Serial>ydot.content).data[0] = d_dt_V
    (<Sundials.N_VectorContent_Serial>ydot.content).data[1] = d_dt_m
    (<Sundials.N_VectorContent_Serial>ydot.content).data[2] = d_dt_h
    (<Sundials.N_VectorContent_Serial>ydot.content).data[3] = d_dt_n


cdef class TestModel(CvodeSolver):

    # The name of the free variable, for use in the ModelWrapperEnvironment
    # From: fc.simulations.AbstractOdeModel
    cdef public str free_variable_name

    # The value of the free variable
    # From: fc.simulations.AbstractOdeModel
    cdef public double free_variable

    # A mapping from variable name to index within the state variable vector,
    # for use in the ModelWrapperEnvironment
    # From: fc.simulations.AbstractOdeModel
    cdef public object state_var_map

    # A numpy array containing initial values for the state variables
    # From: fc.simulations.AbstractOdeModel
    cdef public np.ndarray initial_state

    # A mapping from parameter name to index within the parameters vector, for
    # use in the ModelWrapperEnvironment
    # From: fc.simulations.AbstractOdeModel
    cdef public object parameter_map

    # A numpy array containing model parameter values
    # From: fc.simulations.AbstractOdeModel
    cdef public np.ndarray parameters

    # An ordered list of the names of the model outputs, as they will be
    # returned by get_outputs
    # From: fc.simulations.AbstractOdeModel
    cdef public object output_names

    # Mapping from names to saved model states.
    # From: fc.simulations.AbstractOdeModel
    cdef public object saved_states

    # Maps qualified variable names to model variables (outputs, states,
    # parameters, or the free variable).
    # From: fc.simulations.AbstractOdeModel
    # See: fc.environment.ModelWrapperEnvironment
    cdef public object env

    # True if the solver needs to be reset due to a model change made in the
    # ModelWrapperEnvironment.
    # From: fc.simulations.AbstractOdeModel
    cdef public bint dirty

    # Environment for the simulation running this model. Mainly useful when
    # evaluating set_variable() type modifiers during the course of a
    # simulation.

    # Where to write protocol outputs, error logs, etc.
    # From: fc.simulations.AbstractModel
    cdef public char* output_path

    # Level of indentation to use for progress output.
    # From: fc.simulations.AbstractModel
    cdef public object indent_level

    # Link to generated module.
    # Set in: fc.protocol.Protocol
    # Note: Nobody seems to ever access this variable. Seems this is just to
    # prevent garbage collection.
    cdef public object _module

    # TODO: Not sure if needed
    cdef public object sim_env

    # Cached list of output values (single values or vectors e.g. the state) to
    # avoid recreating a list every time output is returned.
    cdef public object _outputs

    # Seems to be unused at the moment
    #cdef Sundials.N_Vector _parameters

    def __init__(self):
        self.free_variable_name = "time"  # TODO: Should be taken from annotation
        self.free_variable = 0.0

        # State values
        self.state = np.zeros(4)

        # Mapping from qualified names to state indices; only for states that
        # have a variable name.
        self.state_var_map = {}
        self.state_var_map['membrane_voltage'] = 0

        # Initial state
        self.initial_state = np.zeros(4)
        self.initial_state[0] = -75.0
        self.initial_state[1] = 0.05
        self.initial_state[2] = 0.6
        self.initial_state[3] = 0.325

        # Mapping of parameter qualified names to parameter array indices
        self.parameter_map = {}
        self.parameter_map['membrane_fast_sodium_current_conductance'] = 0
        self.parameter_map['membrane_potassium_current_conductance'] = 1

        # Initial parameter values
        self.parameters = np.zeros(2)
        self.parameters[0] = 120.0
        self.parameters[1] = 36.0

        # Local names of output variables
        self.output_names = []
        self.output_names.append('membrane_fast_sodium_current')
        self.output_names.append('membrane_voltage')
        self.output_names.append('time')
        self.output_names.append('state_variable')

        # Create and cache list of arrays, to avoid constant list/array creation
        self._outputs = []
        self._outputs.append(np.array(0.0))
        self._outputs.append(np.array(0.0))
        self._outputs.append(np.array(0.0))
        self._outputs.append(np.zeros(4))

        self.state = self.initial_state.copy()
        self.saved_states = {}
        self.dirty = False
        self.indent_level = 0
        self.associate_with_model(self)
        #self._parameters = Sundials.N_VMake_Serial(
        #    len(self.parameters),
        #    <Sundials.realtype*>(<np.ndarray>self.parameters).data
        #)
        self.env = ModelWrapperEnvironment(self)

    #def __dealloc__(self):
    #    if self._parameters != NULL:
    #        Sundials.N_VDestroy_Serial(self._parameters)

    def get_environment_map(self):
        """
        Get a map from ontology prefix to the environment containing model
        variables annotated with that ontology.

        See :meth:`fc.simulations.AbstractOdeModel.get_environment_map()`.
        """
        # TODO Some part of this might need to be generated
        return {
            'pycml': self.env,
            'cmeta': self.env,
            'cg': self.env,
            'csub': self.env,
            'cs': self.env,
            'oxmeta': self.env,
            'lut': self.env,
            'proto': self.env,
            'None': self.env,
            'bqs': self.env,
            'pe': self.env,
            'dcterms': self.env,
            'xml': self.env,
            'dc': self.env,
            'bqbiol': self.env,
            'cml': self.env,
            'solver': self.env,
            'doc': self.env,
            'm': self.env,
            'rdf': self.env,
            'cellml': self.env,
            'vCard': self.env,
        }

    cpdef get_outputs(self):
        """
        Return a list of the model's outputs at its current state.

        NB: this should return a Python list containing the model outputs as
        numpy arrays, not subclasses of V.AbstractValue.
        The order of outputs in this list must match self.output_names, a list
        of the output names, which must be set by subclass constructors.

        See :meth:`fc.simulations.AbstractModel.get_outputs()`.
        """

        # Get parameters as sundials realtype numpy array
        cdef np.ndarray[Sundials.realtype, ndim=1] parameters = self.parameters

        # Get current free variable
        cdef double var_time = self.free_variable

        # Unpack state variables
        cdef double var_V = self.state[0]
        cdef double var_m = self.state[1]
        cdef double var_h = self.state[2]
        cdef double var_n = self.state[3]

        # Mathematics
        cdef double var_E_R = -75.0
        cdef double var_E_Na = 115.0 + var_E_R
        cdef double var_g_Na = parameters[0]
        cdef double var_i_Na = var_m**3.0 * (-var_E_Na + var_V) * var_g_Na * var_h

        # Update output vector and return
        outputs = self._outputs
        outputs[0][()] = var_i_Na
        outputs[1][()] = var_V
        outputs[2][()] = var_time
        outputs[3][0] = var_V
        outputs[3][1] = var_m
        outputs[3][2] = var_h
        outputs[3][3] = var_n
        return outputs

    cpdef reset_state(self, name=None):
        """
        Reset the model to the given named saved state, or to initial
        conditions if no name given.

        See :meth:`fc.simulations.AbstractOdeModel.reset_state()`.
        """
        if name is None:
            CvodeSolver.reset_solver(self, self.initial_state)
        else:
            CvodeSolver.reset_solver(self, self.saved_states[name])

    def save_state(self, name):
        """
        Save a copy of the current model state associated with the given name,
        to be restored using :meth:`reset_state()`.

        See :meth:`fc.simulations.AbstractOdeModel.save_state()`.
        """
        self.saved_states[name] = self.state.copy()

    cpdef set_free_variable(self, double t):
        """
        Set the value of the free variable (typically time), but retain the
        model's current state.

        See :meth:`fc.simulations.AbstractOdeModel.set_free_variable()`.
        """
        self.free_variable = t
        CvodeSolver.set_free_variable(self, t)

    def set_indent_level(self, indent_level):
        """
        Set the level of indentation to use for progress output.

        See :meth:`fc.simulations.AbstractModel.set_indent_level()`.
        """
        self.indent_level = indent_level

    def set_output_folder(self, path):
        # TODO This is undocumented in fc
        if os.path.isdir(path) and path.startswith('/tmp'):
            shutil.rmtree(path)
        os.mkdir(path)
        self.output_path = path

    def set_rhs_wrapper(self):
        flag = Sundials.CVodeInit(
            self.cvode_mem, _evaluate_rhs, 0.0, self._state)
        self.check_flag(flag, 'CVodeInit')

    def set_solver(self, solver):
        """
        Specify the ODE solver to use for this model.

        See :meth:`fc.simulations.AbstractOdeModel.set_solver()`.
        """
        # TODO Update this (and rest of fc) to Python3
        # TODO Use logging here, or raise an exception
        print >>sys.stderr, '  ' * self.indent_level, 'set_solver: Models implemented using Cython contain a built-in ODE solver, so ignoring setting.'

