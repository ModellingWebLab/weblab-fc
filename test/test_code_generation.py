#
# Tests templating functionality for the Cardiac Electrophysiology Web Lab
#
import cellmlmanip
import logging
import os
import re

import fc.code_generation as cg
from fc.parsing.actions import VariableReference
from fc.parsing.rdf import OXMETA_NS, PRED_IS_VERSION_OF, create_rdf_node


# Show more logging output
logging.getLogger().setLevel(logging.INFO)


def test_unique_name_generation():
    # Tests if unique variable names are generated correctly

    # Load cellml model, get unique names
    model = cellmlmanip.load_model(
        os.path.join('test', 'models', 'conflicting_names.cellml'))

    # Test unique names
    unames = cg.get_unique_names(model)
    assert len(unames) == 9
    symbols = [v for v in model.graph]
    symbols.sort(key=str)

    assert unames[symbols[0]] == 'time'         # env.time
    assert unames[symbols[1]] == 'x__a'         # x.a
    assert unames[symbols[2]] == 'b'            # x.b
    assert unames[symbols[3]] == 'x__y__z_1'    # x.y__z
    assert unames[symbols[4]] == 'x__y__a'      # x__y.a
    assert unames[symbols[5]] == 'x__y__z'      # x__y.x__y__z
    assert unames[symbols[6]] == 'z'            # x__y.z
    assert unames[symbols[7]] == 'z__a'         # z.a
    assert unames[symbols[8]] == 'z__y__z'      # z.y__z


def test_generate_weblab_model(tmp_path):
    # Tests the create_weblab_model() method

    # Select output path (in temporary dir)
    path = tmp_path / 'model.pyx'

    # Select class name
    class_name = 'TestModel'

    # Load cellml model
    model = os.path.join('test', 'models', 'hodgkin_huxley_squid_axon_model_1952_modified.cellml')
    model = cellmlmanip.load_model(model)

    # Select model outputs
    outputs = [
        VariableReference.create('oxmeta', OXMETA_NS, 'membrane_fast_sodium_current'),
        VariableReference.create('oxmeta', OXMETA_NS, 'membrane_voltage'),
        VariableReference.create('oxmeta', OXMETA_NS, 'time'),
        VariableReference.create('oxmeta', OXMETA_NS, 'state_variable'),
    ]

    # Select model parameters
    parameters = [
        VariableReference.create('oxmeta', OXMETA_NS, 'membrane_fast_sodium_current_conductance'),
        VariableReference.create('oxmeta', OXMETA_NS, 'membrane_potassium_current_conductance'),
    ]

    # Annotate state variables with the magic oxmeta:state_variable term
    state_annotation = create_rdf_node((OXMETA_NS, 'state_variable'))
    vector_orderings = {state_annotation: {}}
    for i, state_var in enumerate(model.get_state_symbols()):
        if not state_var.rdf_identity:
            model.add_cmeta_id(state_var)
        model.rdf.add((state_var.rdf_identity, PRED_IS_VERSION_OF, state_annotation))
        vector_orderings[state_annotation][state_var.cmeta_id] = i

    # Create weblab model at path
    cg.create_weblab_model(str(path), class_name, model, outputs, parameters, vector_orderings)

    # Read expected output from file
    expected = os.path.join('test', 'code_generation', 'weblab_model.pyx')
    with open(expected, 'r') as f:
        expected = f.read()

    # Read generated output from file
    generated = path.read_text()

    # Store locally to update test output file
    if os.environ.get('WEBLAB_REGENERATE_REF'):
        print('REGENERATING CODE GENERATION REFERENCE FILE')
        with open(expected, 'w') as f:
            f.write(generated)

    # Remove line about creation date and version
    p = re.compile('# Generated by .+')
    expected = p.sub('# Generated by me', expected).strip()
    generated = p.sub('# Generated by me', generated).strip()

    # Now they should match
    assert generated == expected

