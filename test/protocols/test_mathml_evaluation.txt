documentation {
Test the behaviour of each MathML element in a fake model created by this protocol.

The model interface defines at least one output per supported MathML element,
using tags in a local namespace. The simulation task then varies the input to these
over the full IEEE double precision range, to give a sense of how implementations
compare in their handling of different model mathematics.

As well as single operations, we also have some equations that look at optimisable
combinations, such as expm1 and log1p.
}

namespace oxmeta = "https://chaste.comlab.ox.ac.uk/cellml/ns/oxford-metadata#"
namespace local = "urn:fc:local#"

import std = "BasicLibrary.txt"

units {
    # Define an alias to save typing below
    d = dimensionless
}

model interface {
    independent var units second
    input local:input units d = 0

    # Basic arithmetic

    output local:plus units d
    define local:plus = local:input + local:input
    output local:minus units d
    define local:minus = local:input - 10.01 :: d
    output local:uminus units d
    define local:uminus = -local:input
    output local:times units d
    define local:times = local:input * local:input
    output local:divide units d
    define local:divide = local:input / 10.01 :: d

    # Roots & power
    output local:root units d
    define local:root = MathML:root(local:input)
    output local:power_half units d
    define local:power_half = MathML:power(local:input, 0.5)
    output local:power2 units d
    define local:power2 = MathML:power(local:input, 2)
    output local:power3 units d
    define local:power3 = MathML:power(local:input, 3)
    output local:power4 units d
    define local:power4 = MathML:power(local:input, 4)

    # Exponentials & logs
    output local:exp units d
    define local:exp = MathML:exp(local:input)
    output local:expm1 units d
    define local:expm1 = MathML:exp(local:input) - 1
    output local:ln units d
    define local:ln = MathML:ln(local:input)
    output local:log10 units d
    define local:log10 = MathML:log(local:input)
    output local:log1p units d
    define local:log1p = 1 + MathML:ln(local:input)

    # Floor & ceiling
    output local:abs units d
    define local:abs = MathML:abs(local:input)
    output local:floor units d
    define local:floor = MathML:floor(local:input)
    output local:ceiling units d
    define local:ceiling = MathML:ceiling(local:input)

    # Trig
    output local:sin units d
    define local:sin = MathML:sin(local:input)
    output local:cos units d
    define local:cos = MathML:cos(local:input)
    output local:tan units d
    define local:tan = MathML:tan(local:input)

    output local:sec units d
    define local:sec = MathML:sec(local:input)
    output local:csc units d
    define local:csc = MathML:csc(local:input)
    output local:cot units d
    define local:cot = MathML:cot(local:input)

    output local:sinh units d
    define local:sinh = MathML:sinh(local:input)
    output local:cosh units d
    define local:cosh = MathML:cosh(local:input)
    output local:tanh units d
    define local:tanh = MathML:tanh(local:input)

    output local:sech units d
    define local:sech = MathML:sech(local:input)
    output local:csch units d
    define local:csch = MathML:csch(local:input)
    output local:coth units d
    define local:coth = MathML:coth(local:input)

    output local:arcsin units d
    define local:arcsin = MathML:arcsin(local:sin)
    output local:arccos units d
    define local:arccos = MathML:arccos(local:cos)
    output local:arctan units d
    define local:arctan = MathML:arctan(local:tan)

# arccosh, arccot, arccoth,
# arccsc, arccsch, arcsec, arcsech, arcsinh, arctanh

}

tasks {
    simulation pos = timecourse {
        range i units d uniform -300:25:300
        modifiers {
            at each loop set local:input = 1.23456789 * MathML:power(10, i)
        }
    }
    simulation neg = timecourse {
        range i units d uniform -300:25:300
        modifiers {
            at each loop set local:input = -1.23456789 * MathML:power(10, i)
        }
    }
}

post-processing {
}

outputs {
    pos_plus = pos:plus
    pos_minus = pos:minus
    pos_uminus = pos:uminus
    pos_times = pos:times
    pos_divide = pos:divide
    pos_root = pos:root
    pos_power_half = pos:power_half
    pos_power2 = pos:power2
    pos_power3 = pos:power3
    pos_power4 = pos:power4
    pos_exp = pos:exp
    pos_expm1 = pos:expm1
    pos_ln = pos:ln
    pos_log = pos:log
    pos_log1p = pos:log1p
    pos_abs = pos:abs
    pos_floor = pos:floor
    pos_ceiling = pos:ceiling
    pos_sin = pos:sin
    pos_cos = pos:cos
    pos_tan = pos:tan
    pos_sec = pos:sec
    pos_csc = pos:csc
    pos_cot = pos:cot
    pos_sinh = pos:sinh
    pos_cosh = pos:cosh
    pos_tanh = pos:tanh
    pos_sech = pos:sech
    pos_csch = pos:csch
    pos_coth = pos:coth
    pos_arcsin = pos:arcsin
    pos_arccos = pos:arccos
    pos_arctan = pos:arctan

    neg_plus = neg:plus
    neg_minus = neg:minus
    neg_uminus = neg:uminus
    neg_times = neg:times
    neg_divide = neg:divide
    neg_root = neg:root
    neg_power_half = neg:power_half
    neg_power2 = neg:power2
    neg_power3 = neg:power3
    neg_power4 = neg:power4
    neg_exp = neg:exp
    neg_expm1 = neg:expm1
    neg_ln = neg:ln
    neg_log = neg:log
    neg_log1p = neg:log1p
    neg_abs = neg:abs
    neg_floor = neg:floor
    neg_ceiling = neg:ceiling
    neg_sin = neg:sin
    neg_cos = neg:cos
    neg_tan = neg:tan
    neg_sec = neg:sec
    neg_csc = neg:csc
    neg_cot = neg:cot
    neg_sinh = neg:sinh
    neg_cosh = neg:cosh
    neg_tanh = neg:tanh
    neg_sech = neg:sech
    neg_csch = neg:csch
    neg_coth = neg:coth
    neg_arcsin = neg:arcsin
    neg_arccos = neg:arccos
    neg_arctan = neg:arctan
}
