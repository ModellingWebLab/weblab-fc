# Basic RELAX NG schema for the draft protocol XML format

namespace proto = "https://chaste.cs.ox.ac.uk/nss/protocol/0.1#"
namespace mathml = "http://www.w3.org/1998/Math/MathML"
namespace cellml = "http://www.cellml.org/cellml/1.0#"

start = proto.protocol

# Variable names etc. within protocols - fairly standard
nc_ident = xsd:token { pattern = "[_a-zA-Z][_0-9a-zA-Z]*" }
ident = xsd:token { pattern = "[_a-zA-Z][_0-9a-zA-Z]*(:[_a-zA-Z][_0-9a-zA-Z]*)*" }

# The root element
proto.protocol = element proto:protocol {
    proto.inputs?,
    proto.imports?,
    proto.library?,
    proto.units?,
    proto.modelInterface?,
    proto.simulations?,
    proto.post-processing?,
    proto.outputVariables?,
    proto.plots?
    }

# Specifies inputs to the protocol.
proto.inputs = element proto:inputs { StatementList }

# Imports of other protocols, either for using them as libraries of functionality,
# or using a complete protocol but changing some inputs.
proto.imports = element proto:import {
    attribute source { xsd:anyURI },
    ( ( attribute prefix { nc_ident }, attribute mergeDefinitions { "false" | "0" }? )
      | attribute mergeDefinitions { "true" | "1" } ),
    proto.setInput*
    } +

# Accessing imported protocol components by prefix
proto.useImports = element proto:useImports {
    attribute prefix { nc_ident }
    }

# Inputs of imported protocols can be set by expressions computed from our inputs.
proto.setInput = element proto:setInput {
    attribute name { nc_ident },
    NumberOrExpression
    }

# A library of routines and definitions for use in the rest of the protocol.
proto.library = element proto:library { StatementList }

# Units declarations; unspecified, but uses CellML at present
any-non-local = element * - (mathml:* | proto:*) { any-non-local* } | attribute * { text } | text
proto.units = element proto:units { any-non-local* & proto.useImports* }

# Better XML definition of model interfacing
proto.modelInterface = element proto:modelInterface {
    proto.useImports?,
    proto.setIndependentVariableUnits?,
    proto.specifyInputVariable*,
    proto.specifyOutputVariable*,
    proto.declareNewVariable*,
    proto.addOrReplaceEquation*,
    proto.unitsConversionRule*
    }

proto.setIndependentVariableUnits = element proto:setIndependentVariableUnits { unitsRef }
proto.specifyInputVariable = element proto:specifyInputVariable { nameRef, unitsRef?, initialValue? }
proto.specifyOutputVariable = element proto:specifyOutputVariable { nameRef, unitsRef? }
proto.declareNewVariable = element proto:declareNewVariable { nameAttr, unitsRef, initialValue? }
proto.addOrReplaceEquation = element proto:addOrReplaceEquation { mathml.apply }
proto.unitsConversionRule = element proto:unitsConversionRule {
    attribute desiredDimensions { ident },
    attribute actualDimensions { ident },
    mathml.lambda
    }

unitsRef = attribute units { ident }
nameRef = attribute name { ident }
initialValue = attribute initial_value { xsd:double }
nameAttr = attribute name { nc_ident }
        
# The simulations to run on the model.  You can have a sequence of simulations,
# but only the outputs from the last are currently available.
proto.simulations = element proto:simulations { Simulation+ }

# A simulations may be a simple timecourse, or nest another simulation.
Simulation = ( proto.timecourseSimulation | proto.nestedSimulation | proto.useImports )

# Post-processing consists of a list of statements in the augmented MathML language.
proto.post-processing = element proto:post-processing { ( StatementList | proto.useImports )+ }

# This element specifies the variables (either from the model or post-processing)
# which should be considered as the protocol output, and will be saved to file.
proto.outputVariables = element proto:outputVariables {
    ( proto.raw | proto.postprocessed | proto.useImports )+
    }

# Specifies a model output as a protocol output.
proto.raw = element proto:raw { OutputVariableDefinition }
# Specifies a post-processing variable as a protocol output.
# In this case the units must also be given explicitly.
proto.postprocessed = element proto:postprocessed {
    OutputVariableDefinition,
    attribute units { text }
    }
# Output variable specifications contain the variable name, and optionally a
# more friendly human-readable description (suitable for use on graph axes etc.).
OutputVariableDefinition =
    attribute description { text }?,
    nameAttr,
    attribute ref { ident }?

# Specify what to plot by default for this protocol.
# The first plot listed should be considered as the primary output of interest.
proto.plots = element proto:plots { ( proto.plot | proto.useImports )+ }
# Each plot must have a title, and can either plot two 1d variables against each
# other, or plot a single variable against the relevant stepper values.  In the
# latter case if the variable has more than one dimension, then you get multiple
# traces.
proto.plot = element proto:plot {
    element proto:title { text },
    ( ( element proto:x { ident },
        element proto:y { ident }
      )
    | element proto:data { ident }
    )
    }

# A timecourse simulation just needs the stepper to loop over, and any modifiers to apply.
proto.timecourseSimulation = element proto:timecourseSimulation { BasicSimulation }
BasicSimulation =
    attribute prefix { nc_ident } ?,
    Stepper,
    proto.modifiers

# A nested simulation also needs to specify the simulation to run at each iteration round
# its loop.
proto.nestedSimulation = element proto:nestedSimulation {
    BasicSimulation,
    ( Simulation | proto.nestedProtocol )
    }

# Initial support for nested protocols.  Eventually these will be represented as another
# kind of model.
proto.nestedProtocol = element proto:nestedProtocol {
    attribute source { xsd:anyURI },
    proto.setInput*,
    element proto:selectOutput { nameAttr }*
    }

# Three kinds of stepper are defined.
Stepper = proto.vectorStepper | proto.uniformStepper | proto.whileStepper

# A vector stepper just gives a list of specific values to use.
# It can reference expressions to provide these, either as single values, or as 1d arrays.
proto.vectorStepper = element proto:vectorStepper {
    StepperAttributes,
    ( Expression | proto.value )+
    }

# A uniform stepper gives a range of values to loop over with a fixed step size.
proto.uniformStepper = element proto:uniformStepper {
    StepperAttributes,
    element proto:start { NumberOrExpression },
    element proto:stop { NumberOrExpression },
    element proto:step { NumberOrExpression }
    }

# A while stepper encodes an outer while loop, which continues until the condition
# evaluates to false.
proto.whileStepper = element proto:whileStepper {
    StepperAttributes,
    element proto:condition { Expression }
    }

# Common attributes to all kinds of stepper.
StepperAttributes =
    nameRef, unitsRef

# Uniform stepper parameters can either be given as just numbers, or computed.
NumberOrExpression = Expression | xsd:double

# Each simulation may have zero or more modifiers...
proto.modifiers = element proto:modifiers { Modifier* }
# ...of which there are 3 kinds.
Modifier = proto.resetState | proto.setVariable | proto.saveState

# This 'modifier' saves the current model state for later reference with resetState.
proto.saveState = element proto:saveState {
    proto.when,
    proto.nc_name
    }

# This modifier resets the model's state; either to a state saved using saveState,
# or to the model's initial conditions if no state name is given.
proto.resetState = element proto:resetState {
    proto.when,
    element proto:state { ident }?
    }

# This modifier sets the value of a variable in the model.
proto.setVariable = element proto:setVariable {
    proto.when,
    proto.name,
    proto.value
    }

# Modifiers can be applied either at the start of a stepper's loop, at each iteration,
# or after all steps have been taken.
proto.when = element proto:when { "AT_START_ONLY" | "EVERY_LOOP" | "AT_END" }

# This gives state name to use (in save/resetState)
proto.nc_name = element proto:name { nc_ident }

# This references a model variable using an ontology term (in setVariable).
proto.name = element proto:name { ident }

# A variable's value can be given either as just a number or as the result of an expression.
proto.value = element proto:value { NumberOrExpression }

# We restrict slightly what MathML is considered an 'expression'; the C++ code will do more
# tests than given here on the internal structure.
Expression = mathml.piecewise | mathml.apply | mathml.lambda | ctoken

# A 'statement list' is an apply of one of our cymbols that extend core MathML.  Each operand
# is a 'statement' which must be an apply of either the assert or return csymbols, or of the
# 'eq' MathML operator (representing assignment).  A return is only allowed within the context
# of a function body.
StatementList = element mathml:apply { attlist-mathml.apply, StatementListCsymbol, mathml.apply+ }
StatementListCsymbol = element mathml:csymbol {
    attribute definitionURL {
        "https://chaste.cs.ox.ac.uk/nss/protocol/statementList"
    } }

# These are most of the special csymbols defined in our language.  There are 3 others
# defined below, which have special content within the element.  All of these should
# appear on an empty csymbol element.
CsymbolNames =
    # Statements
      "https://chaste.cs.ox.ac.uk/nss/protocol/statementList"
    | "https://chaste.cs.ox.ac.uk/nss/protocol/assert"
    | "https://chaste.cs.ox.ac.uk/nss/protocol/return"
    # Expressions
    | "https://chaste.cs.ox.ac.uk/nss/protocol/newArray"
    | "https://chaste.cs.ox.ac.uk/nss/protocol/view"
    | "https://chaste.cs.ox.ac.uk/nss/protocol/index"
    | "https://chaste.cs.ox.ac.uk/nss/protocol/find"
    | "https://chaste.cs.ox.ac.uk/nss/protocol/map"
    | "https://chaste.cs.ox.ac.uk/nss/protocol/fold"
    # Values / expressions wrapping values
    | "https://chaste.cs.ox.ac.uk/nss/protocol/tuple"
    | "https://chaste.cs.ox.ac.uk/nss/protocol/defaultParameter"
    | "https://chaste.cs.ox.ac.uk/nss/protocol/null"

# The accessor csymbol encodes tests of certain properties of variables.
AccessorCsymbolContent =
    attribute definitionURL { "https://chaste.cs.ox.ac.uk/nss/protocol/accessor" },
    ( "IS_SIMPLE_VALUE" | "IS_ARRAY" | "IS_STRING" | "IS_FUNCTION" | "IS_TUPLE" | "IS_NULL" | "IS_DEFAULT"
    | "NUM_DIMS" | "NUM_ELEMENTS" | "SHAPE" )

# The wrap csymbols are syntactic sugar to turn a MathML operator into a lambda expression.
# The number in the URL gives the number of operands, and the text content gives the operator name.
WrapCsymbolContent =
    attribute definitionURL { xsd:anyURI { pattern = "https://chaste.cs.ox.ac.uk/nss/protocol/wrap/\d+" } },
    nc_ident

# This allows construction of string variables for use in array comprehensions.  The text
# content gives the string value.
StringCsymbolContent =
    attribute definitionURL { "https://chaste.cs.ox.ac.uk/nss/protocol/string" },
    text

# We override or extent various aspects of the normal MathML schema. 
include "mathml2.rnc" {
    # We can be more specific about the definitionURL on our csymbols.
    attlist-mathml.csymbol = MATHML.Common.attrib, att-encoding, att-type,
        attribute definitionURL { CsymbolNames }
    mathml.csymbol = element mathml:csymbol {
        attlist-mathml.csymbol | AccessorCsymbolContent | WrapCsymbolContent | StringCsymbolContent
        }

    # Restrict the attribute list for math elements, since they're not top-level.
    attlist-mathml.math = MATHML.Common.attrib

    # Presentation markup is NOT allowed except within annotation-xml.
    # However, that element may contain any XML, so we can just define
    # the presentation elements to not exist :)
    PresInCont = empty
    
    # We don't want to allow empty expressions.
    ContentExpression = Content+

    # Restrict what is allowable "any XML" so ID attrs don't conflict.
    any =
        ( element mathml:* {
             attribute * - ( id | xref ) { text }*,
             any
          }
        | text)*

    # Check numbers of operands using co-occurrence constraints.
    mathml.apply =
        element mathml:apply { attlist-mathml.apply, ApplyContentExpression }

    # I think some operators are wrongly classified in the MathML schema
    # Lets be more specific about the 'misc' operators.
    copmisc = empty
}
    # Extra unary operators that were misc.
    cop1ary |= mathml.root
            | mathml.log
            | mathml.minus
            | cseqop
            | cstatopmoment
            | clogicopquant
    # Be more specific for calculus operators.
    ccalcop1ary |= mathml.int
                | mathml.diff
                | mathml.partialdiff
                | mathml.divergence
                | mathml.grad
                | mathml.curl
                | mathml.laplacian
    ccalcop2ary = mathml.partialdiff
  
    # Extra binary operators that were misc.
    cop2ary |= ccalcop2ary | mathml.minus

    # Restrict number of operands depending on the operator.
    c_operand = ctoken | c0ary | cconstructor | cspecial | cother
    c_not_oper = cquantifier | csemantics

    ApplyContentExpression = (
        (cop1ary, c_operand) & c_not_oper*
      ) | (
        ((crel2ary | cop2ary), c_operand, c_operand) & c_not_oper*
      ) | (
        ((crelnary | copnary | mathml.csymbol), c_operand+) & c_not_oper*
      ) | (
        ((mathml.lambda | mathml.ci), c_operand*) & c_not_oper*
      )

    # Raw numbers often need units; we use CellML for now
    attlist-mathml.cn &= attribute cellml:units { ident }?
